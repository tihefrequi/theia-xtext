this.workbox=this.workbox||{},this.workbox.precaching=function(t,e,n,c,s,r){"use strict";try{self["workbox:precaching:5.0.0-beta.1"]&&_()}catch(t){}const i=[],a={get:()=>i,add(t){i.push(...t)}},o="__WB_REVISION__";function h(t){if(!t)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:t});if("string"==typeof t){const e=new URL(t,location.href);return{cacheKey:e.href,url:e.href}}const{revision:e,url:n}=t;if(!n)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:t});if(!e){const t=new URL(n,location.href);return{cacheKey:t.href,url:t.href}}const c=new URL(n,location.href),r=new URL(n,location.href);return c.searchParams.set(o,e),{cacheKey:c.href,url:r.href}}class u{constructor(t){this.t=e.cacheNames.getPrecacheName(t),this.s=new Map,this.i=new Map,this.o=new Map}addToCacheList(t){for(const e of t){const{cacheKey:t,url:n}=h(e),c="string"!=typeof e&&e.revision?"reload":"default";if(this.s.has(n)&&this.s.get(n)!==t)throw new s.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this.s.get(n),secondEntry:t});if("string"!=typeof e&&e.integrity){if(this.o.has(t)&&this.o.get(t)!==e.integrity)throw new s.WorkboxError("add-to-cache-list-conflicting-integrities",{url:n});this.o.set(t,e.integrity)}this.s.set(n,t),this.i.set(n,c)}}async install({event:t,plugins:e}={}){const n=[],c=[],s=await caches.open(this.t),r=await s.keys(),i=new Set(r.map(t=>t.url));for(const[t,e]of this.s)i.has(e)?c.push(t):n.push({cacheKey:e,url:t});const a=n.map(({cacheKey:n,url:c})=>{const s=this.o.get(n),r=this.i.get(c);return this.h({cacheKey:n,cacheMode:r,event:t,integrity:s,plugins:e,url:c})});return await Promise.all(a),{updatedURLs:n.map(t=>t.url),notUpdatedURLs:c}}async activate(){const t=await caches.open(this.t),e=await t.keys(),n=new Set(this.s.values()),c=[];for(const s of e)n.has(s.url)||(await t.delete(s),c.push(s.url));return{deletedURLs:c}}async h({cacheKey:t,url:e,cacheMode:i,event:a,plugins:o,integrity:h}){const u=new Request(e,{integrity:h,cache:i,credentials:"same-origin"});let l,d=await c.fetchWrapper.fetch({event:a,plugins:o,request:u});for(const t of o||[])"cacheWillUpdate"in t&&(l=t);if(!(l?l.cacheWillUpdate({event:a,request:u,response:d}):d.status<400))throw new s.WorkboxError("bad-precaching-response",{url:e,status:d.status});d.redirected&&(d=await r.copyResponse(d)),await n.cacheWrapper.put({event:a,plugins:o,response:d,request:t===e?u:new Request(t),cacheName:this.t,matchOptions:{ignoreSearch:!0}})}getURLsToCacheKeys(){return this.s}getCachedURLs(){return[...this.s.keys()]}getCacheKeyForURL(t){const e=new URL(t,location.href);return this.s.get(e.href)}async matchPrecache(t){const e=t instanceof Request?t.url:t,n=this.getCacheKeyForURL(e);if(n){return(await caches.open(this.t)).match(n)}}createHandler(t=!0){return async({request:e})=>{try{const n=await this.matchPrecache(e);if(n)return n;throw new s.WorkboxError("missing-precache-entry",{cacheName:this.t,url:e.url})}catch(n){if(t)return fetch(e);throw n}}}createHandlerBoundToURL(t,e=!0){if(!this.getCacheKeyForURL(t))throw new s.WorkboxError("non-precached-url",{url:t});const n=this.createHandler(e),c=new Request(t);return()=>n({request:c})}}let l;const d=()=>(l||(l=new u),l);const w=(t,e)=>{const n=d().getURLsToCacheKeys();for(const c of function*(t,{ignoreURLParametersMatching:e,directoryIndex:n,cleanURLs:c,urlManipulation:s}={}){const r=new URL(t,location.href);r.hash="",yield r.href;const i=function(t,e=[]){for(const n of[...t.searchParams.keys()])e.some(t=>t.test(n))&&t.searchParams.delete(n);return t}(r,e);if(yield i.href,n&&i.pathname.endsWith("/")){const t=new URL(i.href);t.pathname+=n,yield t.href}if(c){const t=new URL(i.href);t.pathname+=".html",yield t.href}if(s){const t=s({url:r});for(const e of t)yield e.href}}(t,e)){const t=n.get(c);if(t)return t}};let f=!1;const y=t=>{f||((({ignoreURLParametersMatching:t=[/^utm_/],directoryIndex:n="index.html",cleanURLs:c=!0,urlManipulation:s}={})=>{const r=e.cacheNames.getPrecacheName();addEventListener("fetch",e=>{const i=w(e.request.url,{cleanURLs:c,directoryIndex:n,ignoreURLParametersMatching:t,urlManipulation:s});if(!i)return;let a=caches.open(r).then(t=>t.match(i)).then(t=>t||fetch(i));e.respondWith(a)})})(t),f=!0)},p=t=>{const e=d(),n=a.get();t.waitUntil(e.install({event:t,plugins:n}).catch(t=>{throw t}))},g=t=>{const e=d();t.waitUntil(e.activate())},L=t=>{d().addToCacheList(t),t.length>0&&(addEventListener("install",p),addEventListener("activate",g))};return t.PrecacheController=u,t.addPlugins=(t=>{a.add(t)}),t.addRoute=y,t.cleanupOutdatedCaches=(()=>{addEventListener("activate",t=>{const n=e.cacheNames.getPrecacheName();t.waitUntil((async(t,e="-precache-")=>{const n=(await caches.keys()).filter(n=>n.includes(e)&&n.includes(self.registration.scope)&&n!==t);return await Promise.all(n.map(t=>caches.delete(t))),n})(n).then(t=>{}))})}),t.createHandler=((t=!0)=>{return d().createHandler(t)}),t.createHandlerBoundToURL=(t=>{return d().createHandlerBoundToURL(t)}),t.getCacheKeyForURL=(t=>{return d().getCacheKeyForURL(t)}),t.matchPrecache=(t=>{return d().matchPrecache(t)}),t.precache=L,t.precacheAndRoute=((t,e)=>{L(t),y(e)}),t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);
//# sourceMappingURL=workbox-precaching.prod.js.map
